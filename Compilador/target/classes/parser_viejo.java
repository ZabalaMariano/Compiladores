
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package TP_Final.compilador;

import TP_Final.tabla_simbolos.ObjCteInt;
import TP_Final.tabla_simbolos.ObjCteReal;
import TP_Final.tabla_simbolos.ObjCteString;
import TP_Final.tabla_simbolos.TablaSimbolos;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.*;
import TP_Final.ast.*;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\056\000\002\002\004\000\002\002\004\000\002\003" +
    "\005\000\002\003\004\000\002\004\003\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\014\005\000" +
    "\002\005\011\000\002\005\015\000\002\006\011\000\002" +
    "\007\006\000\002\017\005\000\002\020\010\000\002\020" +
    "\010\000\002\020\007\000\002\020\007\000\002\021\005" +
    "\000\002\021\007\000\002\021\007\000\002\016\003\000" +
    "\002\016\005\000\002\013\011\000\002\013\011\000\002" +
    "\013\011\000\002\013\011\000\002\013\011\000\002\013" +
    "\011\000\002\010\005\000\002\010\005\000\002\010\003" +
    "\000\002\011\005\000\002\011\005\000\002\011\003\000" +
    "\002\012\003\000\002\012\003\000\002\012\003\000\002" +
    "\012\005\000\002\012\003\000\002\015\014\000\002\015" +
    "\014\000\002\015\014\000\002\015\014\000\002\015\014" +
    "\000\002\015\014" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\235\000\004\033\005\001\002\000\004\002\237\001" +
    "\002\000\004\025\206\001\002\000\012\031\012\037\015" +
    "\040\011\042\007\001\002\000\004\016\203\001\002\000" +
    "\004\006\202\001\002\000\004\011\177\001\002\000\004" +
    "\011\165\001\002\000\004\006\ufffd\001\002\000\004\006" +
    "\ufffa\001\002\000\004\011\023\001\002\000\004\006\ufffc" +
    "\001\002\000\004\006\ufffb\001\002\000\014\002\000\031" +
    "\012\037\015\040\011\042\007\001\002\000\004\006\022" +
    "\001\002\000\016\002\uffff\014\uffff\031\uffff\037\uffff\040" +
    "\uffff\042\uffff\001\002\000\004\011\025\001\002\000\004" +
    "\012\161\001\002\000\014\011\030\041\033\042\026\044" +
    "\036\045\034\001\002\000\022\004\uffde\005\uffde\006\uffde" +
    "\007\uffde\010\uffde\012\uffde\026\uffde\027\uffde\001\002\000" +
    "\022\004\uffda\005\uffda\006\uffda\007\uffda\010\uffda\012\uffda" +
    "\026\uffda\027\uffda\001\002\000\014\011\030\041\033\042" +
    "\026\044\036\045\034\001\002\000\022\004\uffe2\005\uffe2" +
    "\006\uffe2\007\064\010\063\012\uffe2\026\uffe2\027\uffe2\001" +
    "\002\000\010\004\050\005\051\012\126\001\002\000\004" +
    "\011\037\001\002\000\022\004\uffdd\005\uffdd\006\uffdd\007" +
    "\uffdd\010\uffdd\012\uffdd\026\uffdd\027\uffdd\001\002\000\022" +
    "\004\uffdf\005\uffdf\006\uffdf\007\uffdf\010\uffdf\012\uffdf\026" +
    "\uffdf\027\uffdf\001\002\000\022\004\uffdc\005\uffdc\006\uffdc" +
    "\007\uffdc\010\uffdc\012\uffdc\026\uffdc\027\uffdc\001\002\000" +
    "\004\030\040\001\002\000\016\017\046\020\045\021\043" +
    "\022\042\023\044\024\041\001\002\000\014\011\030\041" +
    "\033\042\026\044\036\045\034\001\002\000\014\011\030" +
    "\041\033\042\026\044\036\045\034\001\002\000\014\011" +
    "\030\041\033\042\026\044\036\045\034\001\002\000\014" +
    "\011\030\041\033\042\026\044\036\045\034\001\002\000" +
    "\014\011\030\041\033\042\026\044\036\045\034\001\002" +
    "\000\014\011\030\041\033\042\026\044\036\045\034\001" +
    "\002\000\010\004\050\005\051\027\052\001\002\000\014" +
    "\011\030\041\033\042\026\044\036\045\034\001\002\000" +
    "\014\011\030\041\033\042\026\044\036\045\034\001\002" +
    "\000\004\025\053\001\002\000\014\011\030\041\033\042" +
    "\026\044\036\045\034\001\002\000\012\004\050\005\051" +
    "\026\uffec\027\uffec\001\002\000\006\026\057\027\056\001" +
    "\002\000\014\011\030\041\033\042\026\044\036\045\034" +
    "\001\002\000\004\012\060\001\002\000\022\004\uffd5\005" +
    "\uffd5\006\uffd5\007\uffd5\010\uffd5\012\uffd5\026\uffd5\027\uffd5" +
    "\001\002\000\012\004\050\005\051\026\uffeb\027\uffeb\001" +
    "\002\000\022\004\uffe3\005\uffe3\006\uffe3\007\064\010\063" +
    "\012\uffe3\026\uffe3\027\uffe3\001\002\000\014\011\030\041" +
    "\033\042\026\044\036\045\034\001\002\000\014\011\030" +
    "\041\033\042\026\044\036\045\034\001\002\000\022\004" +
    "\uffe0\005\uffe0\006\uffe0\007\uffe0\010\uffe0\012\uffe0\026\uffe0" +
    "\027\uffe0\001\002\000\022\004\uffe1\005\uffe1\006\uffe1\007" +
    "\uffe1\010\uffe1\012\uffe1\026\uffe1\027\uffe1\001\002\000\022" +
    "\004\uffe4\005\uffe4\006\uffe4\007\064\010\063\012\uffe4\026" +
    "\uffe4\027\uffe4\001\002\000\010\004\050\005\051\027\071" +
    "\001\002\000\004\025\072\001\002\000\014\011\030\041" +
    "\033\042\026\044\036\045\034\001\002\000\006\026\074" +
    "\027\056\001\002\000\004\012\075\001\002\000\022\004" +
    "\uffd6\005\uffd6\006\uffd6\007\uffd6\010\uffd6\012\uffd6\026\uffd6" +
    "\027\uffd6\001\002\000\010\004\050\005\051\027\077\001" +
    "\002\000\004\025\100\001\002\000\014\011\030\041\033" +
    "\042\026\044\036\045\034\001\002\000\006\026\102\027" +
    "\056\001\002\000\004\012\103\001\002\000\022\004\uffd9" +
    "\005\uffd9\006\uffd9\007\uffd9\010\uffd9\012\uffd9\026\uffd9\027" +
    "\uffd9\001\002\000\010\004\050\005\051\027\105\001\002" +
    "\000\004\025\106\001\002\000\014\011\030\041\033\042" +
    "\026\044\036\045\034\001\002\000\006\026\110\027\056" +
    "\001\002\000\004\012\111\001\002\000\022\004\uffd7\005" +
    "\uffd7\006\uffd7\007\uffd7\010\uffd7\012\uffd7\026\uffd7\027\uffd7" +
    "\001\002\000\010\004\050\005\051\027\113\001\002\000" +
    "\004\025\114\001\002\000\014\011\030\041\033\042\026" +
    "\044\036\045\034\001\002\000\006\026\116\027\056\001" +
    "\002\000\004\012\117\001\002\000\022\004\uffd8\005\uffd8" +
    "\006\uffd8\007\uffd8\010\uffd8\012\uffd8\026\uffd8\027\uffd8\001" +
    "\002\000\010\004\050\005\051\027\121\001\002\000\004" +
    "\025\122\001\002\000\014\011\030\041\033\042\026\044" +
    "\036\045\034\001\002\000\006\026\124\027\056\001\002" +
    "\000\004\012\125\001\002\000\022\004\uffd4\005\uffd4\006" +
    "\uffd4\007\uffd4\010\uffd4\012\uffd4\026\uffd4\027\uffd4\001\002" +
    "\000\016\017\134\020\131\021\133\022\130\023\132\024" +
    "\127\001\002\000\004\011\154\001\002\000\004\011\151" +
    "\001\002\000\004\011\146\001\002\000\004\011\143\001" +
    "\002\000\004\011\140\001\002\000\004\011\135\001\002" +
    "\000\014\011\030\041\033\042\026\044\036\045\034\001" +
    "\002\000\010\004\050\005\051\012\137\001\002\000\004" +
    "\012\uffe5\001\002\000\014\011\030\041\033\042\026\044" +
    "\036\045\034\001\002\000\010\004\050\005\051\012\142" +
    "\001\002\000\004\012\uffe7\001\002\000\014\011\030\041" +
    "\033\042\026\044\036\045\034\001\002\000\010\004\050" +
    "\005\051\012\145\001\002\000\004\012\uffea\001\002\000" +
    "\014\011\030\041\033\042\026\044\036\045\034\001\002" +
    "\000\010\004\050\005\051\012\150\001\002\000\004\012" +
    "\uffe6\001\002\000\014\011\030\041\033\042\026\044\036" +
    "\045\034\001\002\000\010\004\050\005\051\012\153\001" +
    "\002\000\004\012\uffe9\001\002\000\014\011\030\041\033" +
    "\042\026\044\036\045\034\001\002\000\010\004\050\005" +
    "\051\012\156\001\002\000\004\012\uffe8\001\002\000\010" +
    "\004\050\005\051\012\160\001\002\000\022\004\uffdb\005" +
    "\uffdb\006\uffdb\007\uffdb\010\uffdb\012\uffdb\026\uffdb\027\uffdb" +
    "\001\002\000\004\013\162\001\002\000\012\031\012\037" +
    "\015\040\011\042\007\001\002\000\014\014\164\031\012" +
    "\037\015\040\011\042\007\001\002\000\004\006\ufff6\001" +
    "\002\000\004\011\025\001\002\000\004\012\167\001\002" +
    "\000\004\013\170\001\002\000\012\031\012\037\015\040" +
    "\011\042\007\001\002\000\014\014\172\031\012\037\015" +
    "\040\011\042\007\001\002\000\006\006\ufff8\032\173\001" +
    "\002\000\004\013\174\001\002\000\012\031\012\037\015" +
    "\040\011\042\007\001\002\000\014\014\176\031\012\037" +
    "\015\040\011\042\007\001\002\000\004\006\ufff7\001\002" +
    "\000\004\043\200\001\002\000\004\012\201\001\002\000" +
    "\004\006\ufff5\001\002\000\016\002\ufffe\014\ufffe\031\ufffe" +
    "\037\ufffe\040\ufffe\042\ufffe\001\002\000\014\011\030\041" +
    "\033\042\026\044\036\045\034\001\002\000\010\004\050" +
    "\005\051\006\ufff9\001\002\000\006\025\230\034\227\001" +
    "\002\000\004\042\207\001\002\000\006\026\212\027\211" +
    "\001\002\000\006\035\223\036\224\001\002\000\004\042" +
    "\215\001\002\000\004\015\213\001\002\000\004\025\214" +
    "\001\002\000\006\035\uffef\036\uffef\001\002\000\006\026" +
    "\212\027\211\001\002\000\006\035\217\036\220\001\002" +
    "\000\004\027\222\001\002\000\004\027\221\001\002\000" +
    "\006\035\uffee\036\uffee\001\002\000\006\035\uffed\036\uffed" +
    "\001\002\000\004\026\226\001\002\000\004\026\225\001" +
    "\002\000\006\025\ufff1\034\ufff1\001\002\000\006\025\ufff0" +
    "\034\ufff0\001\002\000\012\031\ufff4\037\ufff4\040\ufff4\042" +
    "\ufff4\001\002\000\004\042\231\001\002\000\006\026\212" +
    "\027\211\001\002\000\006\035\233\036\234\001\002\000" +
    "\004\026\236\001\002\000\004\026\235\001\002\000\006" +
    "\025\ufff3\034\ufff3\001\002\000\006\025\ufff2\034\ufff2\001" +
    "\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\235\000\006\002\003\017\005\001\001\000\002\001" +
    "\001\000\004\020\204\001\001\000\016\003\017\004\007" +
    "\005\015\006\016\007\013\014\012\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\004\020\005\015" +
    "\006\016\007\013\014\012\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\013\023\001\001\000\002\001\001" +
    "\000\012\010\031\011\030\012\034\015\026\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\010\156\011\030" +
    "\012\034\015\026\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\010\117\011\030\012\034\015\026\001\001\000\012" +
    "\010\111\011\030\012\034\015\026\001\001\000\012\010" +
    "\103\011\030\012\034\015\026\001\001\000\012\010\075" +
    "\011\030\012\034\015\026\001\001\000\012\010\067\011" +
    "\030\012\034\015\026\001\001\000\012\010\046\011\030" +
    "\012\034\015\026\001\001\000\002\001\001\000\010\011" +
    "\066\012\034\015\026\001\001\000\010\011\061\012\034" +
    "\015\026\001\001\000\002\001\001\000\014\010\053\011" +
    "\030\012\034\015\026\016\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\010\060\011\030\012\034\015" +
    "\026\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\012\065\015\026\001" +
    "\001\000\006\012\064\015\026\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\010\053\011\030\012\034\015\026" +
    "\016\072\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\010\053\011\030\012\034\015\026\016\100\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\010\053\011\030\012" +
    "\034\015\026\016\106\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\010\053\011\030\012\034\015\026\016\114" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\010\053" +
    "\011\030\012\034\015\026\016\122\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\010\135\011\030\012\034\015\026\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\010\140\011\030\012\034" +
    "\015\026\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\010\143\011\030\012\034\015\026\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\010\146\011\030\012" +
    "\034\015\026\001\001\000\002\001\001\000\002\001\001" +
    "\000\012\010\151\011\030\012\034\015\026\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\010\154\011\030" +
    "\012\034\015\026\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\003\162\004\007\005\015\006\016\007\013\014" +
    "\012\001\001\000\014\004\020\005\015\006\016\007\013" +
    "\014\012\001\001\000\002\001\001\000\004\013\165\001" +
    "\001\000\002\001\001\000\002\001\001\000\016\003\170" +
    "\004\007\005\015\006\016\007\013\014\012\001\001\000" +
    "\014\004\020\005\015\006\016\007\013\014\012\001\001" +
    "\000\002\001\001\000\002\001\001\000\016\003\174\004" +
    "\007\005\015\006\016\007\013\014\012\001\001\000\014" +
    "\004\020\005\015\006\016\007\013\014\012\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\010\203\011\030\012" +
    "\034\015\026\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\021\207\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\021\215\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\021\231\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /* tabla-simbolos */
    TablaSimbolos tablaSimbolos = new TablaSimbolos();
    
    /* Declaraciones dentro de DECVAR - ENDDEC */
    /* arrays usados para relacion id-tipo correctamente (ya que parsea de afuera hacia adentro)*/
    ArrayList<String> identificadores = new ArrayList<String> ();
    ArrayList<String> tipos = new ArrayList<String> ();
    String identificador;//Para filter
    String tipo;//Para filter
    String identificadoraux;//Para filter
    String tipoaux;//Para filter
    ArrayList<String> constantes = new ArrayList<String> ();
    ArrayList<String> tokens = new ArrayList<String> ();

    String error_sintaxis = "";
    
    /**Metodo al que se llama automaticamente ante algun error sintactico.*/
    public void syntax_error(Symbol s){
    	this.error_sintaxis = ("Error en la linea " + (s.right+1) + " columna " + s.left + ". "
            + s + " no reconocido. valor " + s.value );
    }

    
 



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {


    public String resultado="";
public List<NodoSentencia> a ;
public List<NodoExpresion> b ;


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= pgm EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoPrograma start_val = (NodoPrograma)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // pgm ::= decvar lista_sentencias 
            {
              NodoPrograma RESULT =null;
		int dvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object dv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		 RESULT = new NodoPrograma(ls);
            System.out.println("pgm Regla 0");
            
            if (identificador!=null && tipo!=null)
            {
            	tablaSimbolos.agregarObjeto(identificador, tipo,true);
            	tablaSimbolos.agregarObjeto(identificadoraux, tipoaux,true);
            }
            
/* Invertimos el array de identificadores para matchear correctamente id-tipo */ Collections.reverse(identificadores);
for(int i=0;i<identificadores.size();i++) {
/* Agrego id - tipo a la tabla de simbolos */ tablaSimbolos.agregarObjeto(identificadores.get(i), tipos.get(i),true);}                                   
for(int i=0;i<constantes.size();i++) {
/* Agrego cte - token a la tabla de simbolos */ tablaSimbolos.agregarObjeto(constantes.get(i), tokens.get(i),false);}                                   

            /* mostrar tabla de simbolos / exportarla a txt */
            //tablaSimbolos.getTS(); //tablaSimbolos.imprimirTabla(); rename to getTS
            tablaSimbolos.escribirTabla();
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("pgm",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // lista_sentencias ::= lista_sentencias sentencia eol 
            {
              List<NodoSentencia> RESULT =null;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoSentencia s = (NodoSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				   ls.add(s);
				   RESULT = ls;					
                        System.out.println("sentencias Regla 1"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_sentencias",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // lista_sentencias ::= sentencia eol 
            {
              List<NodoSentencia> RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoSentencia s = (NodoSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				   a = new ArrayList<NodoSentencia>();
                        a.add(s);
                        RESULT = a;
                        System.out.println("sentencia Regla 2"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_sentencias",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // sentencia ::= sentenciaasignacion 
            {
              NodoSentencia RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoAsignacion a = (NodoAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;
                System.out.println("sentencia asignacion Regla 3"); 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // sentencia ::= sentenciaif 
            {
              NodoSentencia RESULT =null;
		int sifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sifright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoIf sif = (NodoIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = sif;
                    System.out.println("sentencia if Regla 4"); 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // sentencia ::= sentenciawhile 
            {
              NodoSentencia RESULT =null;
		int swhileleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int swhileright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoWhile swhile = (NodoWhile)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = swhile;
                    System.out.println("sentencia while Regla 5"); 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // sentencia ::= sentenciaprint 
            {
              NodoSentencia RESULT =null;
		int sprintleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sprintright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoPrint sprint = (NodoPrint)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = sprint;
                    System.out.println("sentencia print Regla 6"); 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // sentenciaasignacion ::= id asignaCTE expresion 
            {
              NodoAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					RESULT= new NodoAsignacion(new NodoIdentificador(id), e);  
                           System.out.println("id asigna expresion Regla 7");
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaasignacion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // sentenciaif ::= palabraif parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC 
            {
              NodoIf RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoIf(c, new NodoThen(ls), null); 
                   System.out.println("if-simple Regla 9"); 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // sentenciaif ::= palabraif parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC palabraelse bloqueA lista_sentencias bloqueC 
            {
              NodoIf RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int ls1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int ls1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		List<NodoSentencia> ls1 = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int ls2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int ls2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls2 = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoIf(c, new NodoThen(ls1), new NodoElse(ls2)); 
                   System.out.println("if-else Regla 10"); 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // sentenciawhile ::= palabrawhile parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC 
            {
              NodoWhile RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoWhile(c, new NodoDo(ls));
                   System.out.println("while Regla 11"); 
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciawhile",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // sentenciaprint ::= palabraprint parentesisA constString parentesisC 
            {
              NodoPrint RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String cs = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                    String p = new String(cs); 
                    if(((String)p).length()>30){
                        p = ((String)p).substring(0, Math.min(((String)p).length(), 30));
                        System.out.println("Warning: String mayor a 30, se aplica trunc. Print CTES Regla 12");/*throw new RuntimeException("ERROR idString mayor a 30 caracteres (Regla 12)");*/
                    } else {
                        System.out.println("Print CTES Regla 12");
                    } 

                   /*almaceno consString en constantes y 'CTE_STR' en token*/ constantes.add(cs); tokens.add("CTE_STR");
				RESULT = new NodoPrint(new NodoConstanteString(p));

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaprint",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // decvar ::= palabradecvar lista palabraenddec 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                   System.out.println("decvar Regla 14"); 
           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvar",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // lista ::= lista corcheteA id lista_declaracion_var palabraint corcheteC 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT=new String(id); 
                if( ( ( String )RESULT ).length()>10 ){
                    id = ( ( String )id ).substring(0, Math.min(( ( String )id ).length(), 10));
                    System.out.println("Warning: ID mayor a 10, se aplica trunc.");
                } 
                System.out.println("lista decvar recursiva id-int Regla 15"); 
                
                /*almaceno id en identificadores y 'int' en tipos*/ 
                identificadores.add(id); tipos.add("int");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // lista ::= lista corcheteA id lista_declaracion_var palabrafloat corcheteC 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT=new String(id); 
                if( ( ( String )RESULT ).length()>10 ){
                    id = ( ( String )id ).substring(0, Math.min( ( ( String )id ).length(), 10));
                    System.out.println("Warning: ID mayor a 10, se aplica trunc.");
                } 
                System.out.println("lista decvar recursiva id-float Regla 16"); 

                /*almaceno id en identificadores y 'float' en tipos*/ 
                identificadores.add(id); tipos.add("float");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // lista ::= corcheteA id lista_declaracion_var palabraint corcheteC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT=new String(id); 
                if( ( ( String )RESULT ).length()>10){
                    id = ( ( String )id ).substring(0, Math.min( ( ( String )id ).length(), 10));
                    System.out.println("Warning: ID mayor a 10, se aplica trunc.");
                }
                System.out.println("lista decvar simple id-int Regla 18"); 

                /*almaceno id en identificadores y 'int' en tipos*/
                identificadores.add(id); tipos.add("int");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // lista ::= corcheteA id lista_declaracion_var palabrafloat corcheteC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT=new String(id); 
                if( ( ( String )RESULT ).length()>10){
                    id = ( ( String )id ).substring(0, Math.min(((String)id).length(), 10));
                    System.out.println("Warning: ID mayor a 10, se aplica trunc.");
                } 
                System.out.println("lista decvar simple id-float Regla 19"); 

                /*almaceno id en identificadores y 'float' en tipos*/
                identificadores.add(id); tipos.add("float");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // lista_declaracion_var ::= corcheteC asigna corcheteA 
            {
              Object RESULT =null;
		
        System.out.println("fin lista declaracion var Regla 21"); 
        
        /* Invertimos el array de identificadores para matchear correctamente id-tipo */                 
        Collections.reverse(identificadores);
        
        /* mostrar array de id y tipos */
        System.out.println("Identificadores: ");
        
        //System.out.println("//---ID y TIPO guardados:---//");
        for(int i=0;i<identificadores.size();i++) {
            //System.out.println("id: " + identificadores.get(i) + " tipo: " +tipos.get(i)); 
            
            /* Agrego id - tipo a la tabla de simbolos */                      
            tablaSimbolos.agregarObjeto(identificadores.get(i), tipos.get(i),true);
        }                               
            
        //System.out.println("//--------------------------//");

        /* limpiarmos los array list para la siguiente declaracion de [id,id,..] := [tipo,tipo,..]*/                                    
        identificadores.clear(); tipos.clear();
 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // lista_declaracion_var ::= coma id lista_declaracion_var palabraint coma 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT=new String(id); 
            if( ( ( String )RESULT ).length()>10){
                id = ( ( String )id ).substring(0, Math.min(((String)id).length(), 10));
                System.out.println("Warning: ID mayor a 10, se aplica trunc.");
            }
            System.out.println("lista declaracion var nuevo par de ID-int Regla 22"); 
            /*almaceno id en identificadores y 'int' en tipos*/
             identificadores.add(id); tipos.add("int");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // lista_declaracion_var ::= coma id lista_declaracion_var palabrafloat coma 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            RESULT=new String(id); 
            if(((String)RESULT).length()>10){
                id = ((String)id).substring(0, Math.min(((String)id).length(), 10));
                System.out.println("Warning: ID mayor a 10, se aplica trunc.");
            }
            System.out.println("lista declaracion var nuevo par de ID-float Regla 23"); 
            /*almaceno id en identificadores y 'float' en tipos*/ 
            identificadores.add(id); tipos.add("float");
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // lista_expresiones ::= expresion 
            {
              List<NodoExpresion> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			b = new ArrayList<NodoExpresion>();
                b.add(e);
                RESULT = b;
                System.out.println("fin lista_expresiones Regla 25"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_expresiones",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // lista_expresiones ::= lista_expresiones coma expresion 
            {
              List<NodoExpresion> RESULT =null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			le.add(e);
			RESULT = le;
                System.out.println("lista_expresiones recursiva Regla 26"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_expresiones",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // condicion ::= parentesisA expresion parentesisC mayor parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMayor(e1, e2);
                System.out.println("Condicion mayor Regla 27"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // condicion ::= parentesisA expresion parentesisC menor parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMenor(e1, e2);
                System.out.println("Condicion menor Regla 28"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // condicion ::= parentesisA expresion parentesisC igual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoIgual(e1, e2);
                System.out.println("Condicion igual Regla 29"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // condicion ::= parentesisA expresion parentesisC mayorigual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMayorIgual(e1, e2);
                System.out.println("Condicion mayorigual Regla 30"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // condicion ::= parentesisA expresion parentesisC menorigual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMenorIgual(e1, e2);
                System.out.println("Condicion menorigual Regla 31"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // condicion ::= parentesisA expresion parentesisC distinto parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoDistinto(e1, e2);
                System.out.println("Condicion distinto Regla 32"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // expresion ::= expresion mas termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoSuma(a, b);
                System.out.println("E+T Regla 33"); 
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // expresion ::= expresion menos termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = new NodoResta(a, b);
                System.out.println("E-T Regla 34");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // expresion ::= termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;
                System.out.println("Termino Regla 35"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // termino ::= termino por factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoMultiplicacion(a, b);
                System.out.println("T*F Regla 36");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // termino ::= termino dividido factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoDivision(a, b);
                System.out.println("T/F Regla 37");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // termino ::= factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;
                System.out.println("Factor Regla 38");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // factor ::= id 
            {
              NodoExpresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT =new NodoIdentificador(id); 
                System.out.println("id Regla 39");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // factor ::= cteReal 
            {
              NodoExpresion RESULT =null;
		int cterealleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cterealright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String ctereal = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                float f= Float.parseFloat(ctereal); 
                if (Float.isInfinite(f)){ 
                    throw new RuntimeException("ERROR variable cteReal mayor a 32bit (Regla 40)");
                    /*System.out.println("ERROR cteReal mayor a 32bit Regla 40");*/ 
                } else {
			    RESULT =new NodoConstanteReal(ctereal);
                    System.out.println("cteReal Regla 40");
                    
                    /*almaceno consFloat en constantes y 'CTE_F' en token*/ 
                    constantes.add(ctereal); tokens.add("CTE_F");
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // factor ::= cte 
            {
              NodoExpresion RESULT =null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String cte = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                try { 
                    Short var_short = Short.valueOf(cte); 
			    RESULT =new NodoConstante(cte);

                    System.out.println("cte Regla 40"); 

                    /*almaceno consEntera en constantes y 'CTE_E' en token*/ 
                    constantes.add(cte); tokens.add("CTE_E");
                }catch(NumberFormatException e) {
                    /*throw new RuntimeException("ERROR variable cte mayor a 16bit (Regla 40)");*/
                    System.out.println("ERROR cte mayor a 16bit Regla 40");
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // factor ::= parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                System.out.println("expresion entre parentesis Regla 41");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // factor ::= filter 
            {
              NodoExpresion RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoFilter f = (NodoFilter)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = f;
                System.out.println("factor filter Regla 42");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // filter ::= palabrafilter parentesisA guion_bajo mayor expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Mayor");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMayor(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,">");
                System.out.println("filter mayor Regla 43"); 
           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // filter ::= palabrafilter parentesisA guion_bajo menor expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";

		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Menor");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMenor(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"<");
                System.out.println("filter menor Regla 44"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // filter ::= palabrafilter parentesisA guion_bajo mayorigual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"MayorIgual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMayorIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,">=");
                System.out.println("filter mayorigual Regla 45"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // filter ::= palabrafilter parentesisA guion_bajo menorigual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"MenorIgual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMenorIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"<=");
                System.out.println("filter menorigual Regla 46"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // filter ::= palabrafilter parentesisA guion_bajo distinto expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Distinto");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoDistinto(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"!=");
                System.out.println("filter distinto Regla 47"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // filter ::= palabrafilter parentesisA guion_bajo igual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
            {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Igual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"==");
                System.out.println("filter igual Regla 48"); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
