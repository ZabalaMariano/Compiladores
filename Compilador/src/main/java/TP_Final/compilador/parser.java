
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package TP_Final.compilador;

import TP_Final.tabla_simbolos.TablaSimbolos;
import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.*;
import TP_Final.ast.*;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\064\000\002\002\004\000\002\002\004\000\002\003" +
    "\005\000\002\003\004\000\002\004\003\000\002\004\003" +
    "\000\002\004\003\000\002\004\003\000\002\004\003\000" +
    "\002\015\005\000\002\005\011\000\002\005\015\000\002" +
    "\006\011\000\002\007\006\000\002\010\006\000\002\020" +
    "\005\000\002\021\010\000\002\021\010\000\002\021\010" +
    "\000\002\021\007\000\002\021\007\000\002\021\007\000" +
    "\002\022\005\000\002\022\007\000\002\022\007\000\002" +
    "\022\007\000\002\017\003\000\002\017\005\000\002\014" +
    "\011\000\002\014\011\000\002\014\011\000\002\014\011" +
    "\000\002\014\011\000\002\014\011\000\002\011\005\000" +
    "\002\011\005\000\002\011\003\000\002\012\005\000\002" +
    "\012\005\000\002\012\003\000\002\013\003\000\002\013" +
    "\003\000\002\013\003\000\002\013\003\000\002\013\005" +
    "\000\002\013\003\000\002\016\014\000\002\016\014\000" +
    "\002\016\014\000\002\016\014\000\002\016\014\000\002" +
    "\016\014" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\247\000\004\033\005\001\002\000\004\002\251\001" +
    "\002\000\004\025\212\001\002\000\012\031\012\040\016" +
    "\041\011\043\007\001\002\000\004\016\207\001\002\000" +
    "\004\006\206\001\002\000\004\011\201\001\002\000\004" +
    "\011\167\001\002\000\004\006\ufffd\001\002\000\004\006" +
    "\ufff9\001\002\000\004\006\ufffa\001\002\000\004\011\024" +
    "\001\002\000\004\006\ufffc\001\002\000\004\006\ufffb\001" +
    "\002\000\014\002\000\031\012\040\016\041\011\043\007" +
    "\001\002\000\004\006\023\001\002\000\016\002\uffff\014" +
    "\uffff\031\uffff\040\uffff\041\uffff\043\uffff\001\002\000\004" +
    "\011\026\001\002\000\004\012\163\001\002\000\016\011" +
    "\032\042\035\043\027\044\031\045\040\046\036\001\002" +
    "\000\022\004\uffd9\005\uffd9\006\uffd9\007\uffd9\010\uffd9\012" +
    "\uffd9\026\uffd9\027\uffd9\001\002\000\022\004\uffd4\005\uffd4" +
    "\006\uffd4\007\uffd4\010\uffd4\012\uffd4\026\uffd4\027\uffd4\001" +
    "\002\000\022\004\uffd8\005\uffd8\006\uffd8\007\uffd8\010\uffd8" +
    "\012\uffd8\026\uffd8\027\uffd8\001\002\000\016\011\032\042" +
    "\035\043\027\044\031\045\040\046\036\001\002\000\022" +
    "\004\uffdd\005\uffdd\006\uffdd\007\057\010\056\012\uffdd\026" +
    "\uffdd\027\uffdd\001\002\000\010\004\052\005\054\012\130" +
    "\001\002\000\004\011\041\001\002\000\022\004\uffd7\005" +
    "\uffd7\006\uffd7\007\uffd7\010\uffd7\012\uffd7\026\uffd7\027\uffd7" +
    "\001\002\000\022\004\uffda\005\uffda\006\uffda\007\uffda\010" +
    "\uffda\012\uffda\026\uffda\027\uffda\001\002\000\022\004\uffd6" +
    "\005\uffd6\006\uffd6\007\uffd6\010\uffd6\012\uffd6\026\uffd6\027" +
    "\uffd6\001\002\000\004\030\042\001\002\000\016\017\050" +
    "\020\046\021\047\022\044\023\045\024\043\001\002\000" +
    "\016\011\032\042\035\043\027\044\031\045\040\046\036" +
    "\001\002\000\016\011\032\042\035\043\027\044\031\045" +
    "\040\046\036\001\002\000\016\011\032\042\035\043\027" +
    "\044\031\045\040\046\036\001\002\000\016\011\032\042" +
    "\035\043\027\044\031\045\040\046\036\001\002\000\016" +
    "\011\032\042\035\043\027\044\031\045\040\046\036\001" +
    "\002\000\016\011\032\042\035\043\027\044\031\045\040" +
    "\046\036\001\002\000\010\004\052\005\054\027\053\001" +
    "\002\000\016\011\032\042\035\043\027\044\031\045\040" +
    "\046\036\001\002\000\004\025\062\001\002\000\016\011" +
    "\032\042\035\043\027\044\031\045\040\046\036\001\002" +
    "\000\022\004\uffde\005\uffde\006\uffde\007\057\010\056\012" +
    "\uffde\026\uffde\027\uffde\001\002\000\016\011\032\042\035" +
    "\043\027\044\031\045\040\046\036\001\002\000\016\011" +
    "\032\042\035\043\027\044\031\045\040\046\036\001\002" +
    "\000\022\004\uffdb\005\uffdb\006\uffdb\007\uffdb\010\uffdb\012" +
    "\uffdb\026\uffdb\027\uffdb\001\002\000\022\004\uffdc\005\uffdc" +
    "\006\uffdc\007\uffdc\010\uffdc\012\uffdc\026\uffdc\027\uffdc\001" +
    "\002\000\016\011\032\042\035\043\027\044\031\045\040" +
    "\046\036\001\002\000\012\004\052\005\054\026\uffe7\027" +
    "\uffe7\001\002\000\006\026\066\027\065\001\002\000\016" +
    "\011\032\042\035\043\027\044\031\045\040\046\036\001" +
    "\002\000\004\012\067\001\002\000\022\004\uffcf\005\uffcf" +
    "\006\uffcf\007\uffcf\010\uffcf\012\uffcf\026\uffcf\027\uffcf\001" +
    "\002\000\012\004\052\005\054\026\uffe6\027\uffe6\001\002" +
    "\000\022\004\uffdf\005\uffdf\006\uffdf\007\057\010\056\012" +
    "\uffdf\026\uffdf\027\uffdf\001\002\000\010\004\052\005\054" +
    "\027\073\001\002\000\004\025\074\001\002\000\016\011" +
    "\032\042\035\043\027\044\031\045\040\046\036\001\002" +
    "\000\006\026\076\027\065\001\002\000\004\012\077\001" +
    "\002\000\022\004\uffd1\005\uffd1\006\uffd1\007\uffd1\010\uffd1" +
    "\012\uffd1\026\uffd1\027\uffd1\001\002\000\010\004\052\005" +
    "\054\027\101\001\002\000\004\025\102\001\002\000\016" +
    "\011\032\042\035\043\027\044\031\045\040\046\036\001" +
    "\002\000\006\026\104\027\065\001\002\000\004\012\105" +
    "\001\002\000\022\004\uffd0\005\uffd0\006\uffd0\007\uffd0\010" +
    "\uffd0\012\uffd0\026\uffd0\027\uffd0\001\002\000\010\004\052" +
    "\005\054\027\107\001\002\000\004\025\110\001\002\000" +
    "\016\011\032\042\035\043\027\044\031\045\040\046\036" +
    "\001\002\000\006\026\112\027\065\001\002\000\004\012" +
    "\113\001\002\000\022\004\uffd3\005\uffd3\006\uffd3\007\uffd3" +
    "\010\uffd3\012\uffd3\026\uffd3\027\uffd3\001\002\000\010\004" +
    "\052\005\054\027\115\001\002\000\004\025\116\001\002" +
    "\000\016\011\032\042\035\043\027\044\031\045\040\046" +
    "\036\001\002\000\006\026\120\027\065\001\002\000\004" +
    "\012\121\001\002\000\022\004\uffd2\005\uffd2\006\uffd2\007" +
    "\uffd2\010\uffd2\012\uffd2\026\uffd2\027\uffd2\001\002\000\010" +
    "\004\052\005\054\027\123\001\002\000\004\025\124\001" +
    "\002\000\016\011\032\042\035\043\027\044\031\045\040" +
    "\046\036\001\002\000\006\026\126\027\065\001\002\000" +
    "\004\012\127\001\002\000\022\004\uffce\005\uffce\006\uffce" +
    "\007\uffce\010\uffce\012\uffce\026\uffce\027\uffce\001\002\000" +
    "\016\017\136\020\135\021\134\022\132\023\133\024\131" +
    "\001\002\000\004\011\156\001\002\000\004\011\153\001" +
    "\002\000\004\011\150\001\002\000\004\011\145\001\002" +
    "\000\004\011\142\001\002\000\004\011\137\001\002\000" +
    "\016\011\032\042\035\043\027\044\031\045\040\046\036" +
    "\001\002\000\010\004\052\005\054\012\141\001\002\000" +
    "\004\012\uffe0\001\002\000\016\011\032\042\035\043\027" +
    "\044\031\045\040\046\036\001\002\000\010\004\052\005" +
    "\054\012\144\001\002\000\004\012\uffe1\001\002\000\016" +
    "\011\032\042\035\043\027\044\031\045\040\046\036\001" +
    "\002\000\010\004\052\005\054\012\147\001\002\000\004" +
    "\012\uffe2\001\002\000\016\011\032\042\035\043\027\044" +
    "\031\045\040\046\036\001\002\000\010\004\052\005\054" +
    "\012\152\001\002\000\004\012\uffe5\001\002\000\016\011" +
    "\032\042\035\043\027\044\031\045\040\046\036\001\002" +
    "\000\010\004\052\005\054\012\155\001\002\000\004\012" +
    "\uffe4\001\002\000\016\011\032\042\035\043\027\044\031" +
    "\045\040\046\036\001\002\000\010\004\052\005\054\012" +
    "\160\001\002\000\004\012\uffe3\001\002\000\010\004\052" +
    "\005\054\012\162\001\002\000\022\004\uffd5\005\uffd5\006" +
    "\uffd5\007\uffd5\010\uffd5\012\uffd5\026\uffd5\027\uffd5\001\002" +
    "\000\004\013\164\001\002\000\012\031\012\040\016\041" +
    "\011\043\007\001\002\000\014\014\166\031\012\040\016" +
    "\041\011\043\007\001\002\000\004\006\ufff5\001\002\000" +
    "\004\011\026\001\002\000\004\012\171\001\002\000\004" +
    "\013\172\001\002\000\012\031\012\040\016\041\011\043" +
    "\007\001\002\000\014\014\174\031\012\040\016\041\011" +
    "\043\007\001\002\000\006\006\ufff7\032\175\001\002\000" +
    "\004\013\176\001\002\000\012\031\012\040\016\041\011" +
    "\043\007\001\002\000\014\014\200\031\012\040\016\041" +
    "\011\043\007\001\002\000\004\006\ufff6\001\002\000\006" +
    "\043\203\044\202\001\002\000\004\012\205\001\002\000" +
    "\004\012\204\001\002\000\004\006\ufff3\001\002\000\004" +
    "\006\ufff4\001\002\000\016\002\ufffe\014\ufffe\031\ufffe\040" +
    "\ufffe\041\ufffe\043\ufffe\001\002\000\016\011\032\042\035" +
    "\043\027\044\031\045\040\046\036\001\002\000\010\004" +
    "\052\005\054\006\ufff8\001\002\000\006\025\240\034\237" +
    "\001\002\000\004\043\213\001\002\000\006\026\216\027" +
    "\215\001\002\000\010\035\231\036\232\037\233\001\002" +
    "\000\004\043\221\001\002\000\004\015\217\001\002\000" +
    "\004\025\220\001\002\000\010\035\uffeb\036\uffeb\037\uffeb" +
    "\001\002\000\006\026\216\027\215\001\002\000\010\035" +
    "\223\036\224\037\225\001\002\000\004\027\230\001\002" +
    "\000\004\027\227\001\002\000\004\027\226\001\002\000" +
    "\010\035\uffe8\036\uffe8\037\uffe8\001\002\000\010\035\uffea" +
    "\036\uffea\037\uffea\001\002\000\010\035\uffe9\036\uffe9\037" +
    "\uffe9\001\002\000\004\026\236\001\002\000\004\026\235" +
    "\001\002\000\004\026\234\001\002\000\006\025\uffec\034" +
    "\uffec\001\002\000\006\025\uffee\034\uffee\001\002\000\006" +
    "\025\uffed\034\uffed\001\002\000\012\031\ufff2\040\ufff2\041" +
    "\ufff2\043\ufff2\001\002\000\004\043\241\001\002\000\006" +
    "\026\216\027\215\001\002\000\010\035\243\036\244\037" +
    "\245\001\002\000\004\026\250\001\002\000\004\026\247" +
    "\001\002\000\004\026\246\001\002\000\006\025\uffef\034" +
    "\uffef\001\002\000\006\025\ufff1\034\ufff1\001\002\000\006" +
    "\025\ufff0\034\ufff0\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\247\000\006\002\003\020\005\001\001\000\002\001" +
    "\001\000\004\021\210\001\001\000\020\003\020\004\007" +
    "\005\016\006\017\007\014\010\013\015\012\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\004\021\005\016\006\017\007\014\010\013\015" +
    "\012\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\014\024\001\001\000\002\001\001\000\012\011\033\012" +
    "\032\013\036\016\027\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\011\160\012\032\013" +
    "\036\016\027\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\011\121\012\032\013\036\016\027\001\001\000\012\011" +
    "\113\012\032\013\036\016\027\001\001\000\012\011\105" +
    "\012\032\013\036\016\027\001\001\000\012\011\077\012" +
    "\032\013\036\016\027\001\001\000\012\011\071\012\032" +
    "\013\036\016\027\001\001\000\012\011\050\012\032\013" +
    "\036\016\027\001\001\000\002\001\001\000\010\012\070" +
    "\013\036\016\027\001\001\000\002\001\001\000\010\012" +
    "\054\013\036\016\027\001\001\000\002\001\001\000\006" +
    "\013\060\016\027\001\001\000\006\013\057\016\027\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\011\062" +
    "\012\032\013\036\016\027\017\063\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\011\067\012\032\013\036" +
    "\016\027\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\011\062\012\032\013\036\016\027\017" +
    "\074\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\011" +
    "\062\012\032\013\036\016\027\017\102\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\011\062\012\032\013\036" +
    "\016\027\017\110\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\011\062\012\032\013\036\016\027\017\116\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\011\062\012" +
    "\032\013\036\016\027\017\124\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\011" +
    "\137\012\032\013\036\016\027\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\011\142\012\032\013\036\016" +
    "\027\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\011\145\012\032\013\036\016\027\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\011\150\012\032\013\036" +
    "\016\027\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\011\153\012\032\013\036\016\027\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\011\156\012\032\013" +
    "\036\016\027\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\003\164\004\007\005\016\006\017\007\014\010\013" +
    "\015\012\001\001\000\016\004\021\005\016\006\017\007" +
    "\014\010\013\015\012\001\001\000\002\001\001\000\004" +
    "\014\167\001\001\000\002\001\001\000\002\001\001\000" +
    "\020\003\172\004\007\005\016\006\017\007\014\010\013" +
    "\015\012\001\001\000\016\004\021\005\016\006\017\007" +
    "\014\010\013\015\012\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\003\176\004\007\005\016\006\017\007" +
    "\014\010\013\015\012\001\001\000\016\004\021\005\016" +
    "\006\017\007\014\010\013\015\012\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\011\207\012\032\013\036\016\027\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\022" +
    "\213\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\022" +
    "\221\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\022\241\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


/* tabla-simbolos */
  TablaSimbolos tablaSimbolos = new TablaSimbolos();
  
  /* Declaraciones dentro de DECVAR - ENDDEC */
  /* arrays usados para relacion id-tipo correctamente (ya que parsea de afuera hacia adentro)*/
  ArrayList<String> identificadores = new ArrayList<String> ();
  ArrayList<String> tipos = new ArrayList<String> ();
  String identificador;//Para filter
  String tipo;//Para filter
  String identificadoraux;//Para filter
  String tipoaux;//Para filter
  ArrayList<String> constantes = new ArrayList<String> ();
  ArrayList<String> tokens = new ArrayList<String> ();
  String listaReglas = "";
  String error_sintaxis = "";
  ArrayList<String> allIdentificadores = new ArrayList<String>();
  ArrayList<String> allTipos = new ArrayList<String>();
  
  /**Metodo al que se llama automaticamente ante algun error sintactico.*/
  public void syntax_error(Symbol s){
  	this.error_sintaxis = ("Error en la linea " + (s.right+1) + ". Valor " + s.value );
  }

/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {


    public String resultado="";
public List<NodoSentencia> a ;
public List<NodoExpresion> b ;


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= pgm EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoPrograma start_val = (NodoPrograma)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // pgm ::= decvar lista_sentencias 
            {
              NodoPrograma RESULT =null;
		int dvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object dv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
		 RESULT = new NodoPrograma(ls);
            
		 listaReglas = listaReglas + "[Regla 0] Programa" + "\n";	
		 
		//BORRAR////////////////////////////////////v
		 System.out.println("//---ALL ID y TIPO guardados: case 1---//");
	     for(int i=0;i<allIdentificadores.size();i++) {
	            System.out.println("id: " + allIdentificadores.get(i) + " tipo: " +allTipos.get(i));
		 }
	   //BORRAR////////////////////////////////////v
		 
		 /* Invertimos el array de identificadores para matchear correctamente id-tipo */ 
		 //Collections.reverse(identificadores);
		 
		 System.out.println("//---ID y TIPO guardados: case 1---//");
	     for(int i=0;i<identificadores.size();i++) {
	            System.out.println("id: " + identificadores.get(i) + " tipo: " +tipos.get(i));	
	            /* Agrego id - tipo a la tabla de simbolos */ 
	            tablaSimbolos.agregarObjeto(identificadores.get(i), tipos.get(i),true);
		 }
		 for(int i=0;i<constantes.size();i++) {
		 /* Agrego cte - token a la tabla de simbolos */ 
			 tablaSimbolos.agregarObjeto(constantes.get(i), tokens.get(i),false);
		 }                                   

		 if (identificador!=null && tipo!=null)
		 {
			tablaSimbolos.agregarObjeto(identificador, tipo,true);
			tablaSimbolos.agregarObjeto(identificadoraux, tipoaux,true);
		 }

         /* mostrar tabla de simbolos / exportarla a txt */
         //tablaSimbolos.imprimirTabla();
         tablaSimbolos.escribirTabla();
    
         CUP$parser$result = parser.getSymbolFactory().newSymbol("pgm",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        } 
            
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // lista_sentencias ::= lista_sentencias sentencia eol 
            {
              List<NodoSentencia> RESULT =null;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoSentencia s = (NodoSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				   ls.add(s);
				   RESULT = ls;					

				   listaReglas = listaReglas + "[Regla 1] Lista de sentencias" + "\n";
				   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_sentencias",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // lista_sentencias ::= sentencia eol 
            {
              List<NodoSentencia> RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoSentencia s = (NodoSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				   a = new ArrayList<NodoSentencia>();
                        a.add(s);
                        RESULT = a;

                        listaReglas = listaReglas + "[Regla 2] Sentencia" + "\n";                        
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_sentencias",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // sentencia ::= sentenciaasignacion 
            {
              NodoSentencia RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoAsignacion a = (NodoAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;

			listaReglas = listaReglas + "[Regla 3] Sentencia Asignacion" + "\n";
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // sentencia ::= sentenciaif 
            {
              NodoSentencia RESULT =null;
		int sifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sifright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoIf sif = (NodoIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = sif;
			    
			    listaReglas = listaReglas + "[Regla 4] Sentencia IF" + "\n"; 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // sentencia ::= sentenciawhile 
            {
              NodoSentencia RESULT =null;
		int swhileleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int swhileright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoWhile swhile = (NodoWhile)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = swhile;
                   
			    listaReglas = listaReglas + "[Regla 5] Sentencia WHILE" + "\n"; 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // sentencia ::= sentenciaprint 
            {
              NodoSentencia RESULT =null;
		int sprintleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sprintright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoPrint sprint = (NodoPrint)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = sprint;
                    
			    listaReglas = listaReglas + "[Regla 6] Sentencia PRINT CTES" + "\n";
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // sentencia ::= sentenciaprintidentificador 
            {
              NodoSentencia RESULT =null;
		int sprintleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sprintright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoPrintIdentificador sprint = (NodoPrintIdentificador)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT = sprint;

			    listaReglas = listaReglas + "[Regla 7] Sentencia PRINT ID String" + "\n";
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // sentenciaasignacion ::= id asignaCTE expresion 
            {
              NodoAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

		String exp = e.getDescripcionNodo();
		String idTipo = "";
		//**
		ArrayList<String> identificadores2 = identificadores;
		Collections.reverse(identificadores2);
		for(int i=0; i<identificadores2.size(); i++) {
			if(identificadores2.get(i).equals(id)) {
				idTipo = tipos.get(i);
			}
		}
		for(int i=0; i<allIdentificadores.size(); i++) {
			if(allIdentificadores.get(i).equals(id)) {
				idTipo = allTipos.get(i);
			}
		}
		
		if(exp.contains("CTE_E")) {
			if(!idTipo.equals("int")) {				
				listaReglas = listaReglas + "ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_E.";
				throw new RuntimeException("ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_E.");
			}
		}
		else if(exp.contains("CTE_F")) {
			if(!idTipo.equals("float")) {
				listaReglas = listaReglas + "ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_F.";
				throw new RuntimeException("ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_F.");
			}
		}
		else if(exp.contains("CTE_STR")) {
			if(!idTipo.equals("string")) {				
				listaReglas = listaReglas + "ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_STR.";
				throw new RuntimeException("ERROR [Regla 8] Asignacion: ID := Expresion. ID " + id + " es tipo "
						+ idTipo + " y la constante es tipo CTE_STR.");
			}
		}
		
		RESULT= new NodoAsignacion(new NodoIdentificador(id), e);  
		
		listaReglas = listaReglas + "[Regla 8] Asignacion: ID := Expresion" + "\n";
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaasignacion",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // sentenciaif ::= palabraif parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC 
            {
              NodoIf RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoIf(c, new NodoThen(ls), null); 
               
			   listaReglas = listaReglas + "[Regla 9] IF: Simple" + "\n";
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // sentenciaif ::= palabraif parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC palabraelse bloqueA lista_sentencias bloqueC 
            {
              NodoIf RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int ls1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int ls1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		List<NodoSentencia> ls1 = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int ls2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int ls2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls2 = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoIf(c, new NodoThen(ls1), new NodoElse(ls2)); 

			   listaReglas = listaReglas + "[Regla 10] IF: if-else" + "\n"; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaif",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // sentenciawhile ::= palabrawhile parentesisA condicion parentesisC bloqueA lista_sentencias bloqueC 
            {
              NodoWhile RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		//NodoExpresion c = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		NodoCondicion c = (NodoCondicion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<NodoSentencia> ls = (List<NodoSentencia>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			   RESULT= new NodoWhile(c, new NodoDo(ls));
               
			   listaReglas = listaReglas + "[Regla 11] WHILE" + "\n";
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciawhile",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // sentenciaprint ::= palabraprint parentesisA constString parentesisC 
            {
              NodoPrint RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String cs = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                    String p = new String(cs);
                    
                    if(p.length()>32){
                        p = p.substring(0, 31) + "\"";
                        
                        listaReglas = listaReglas + "WARNING [Regla 12] PRINT CTES: excede los 30 caracteres. Es recortado." + "\n";
                        
                    } else {
                    	listaReglas = listaReglas + "[Regla 12] PRINT CTES" + "\n";
                    }

                   /*almaceno consString en constantes y 'CTE_STR' en token*/
                    constantes.add(p); tokens.add("CTE_STR");
                    
				RESULT = new NodoPrint(new NodoConstanteString(p));
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaprint",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // sentenciaprintidentificador ::= palabraprint parentesisA id parentesisC 
            {
              NodoPrintIdentificador RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		RESULT = new NodoPrintIdentificador(new NodoIdentificador(id));
		
		listaReglas = listaReglas + "[Regla 13] PRINT ID String" + "\n";
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentenciaprintidentificador",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // decvar ::= palabradecvar lista palabraenddec 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
		listaReglas = listaReglas + "[Regla 14] DECVAR-ENDDEC" + "\n"; 
           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvar",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // lista ::= lista corcheteA id lista_declaracion_var palabraint corcheteC 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                 
		if (id.length()>10){
        	id = id.substring(0, 9);
                    
            listaReglas = listaReglas + "WARNING [Regla 15] Declaracion nuevo par final recursiva, ID-INT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 15] Declaracion nuevo par final recursiva, ID-INT" + "\n";	
        } 
                
        /*almaceno id en identificadores y 'int' en tipos*/ 
        identificadores.add(id); tipos.add("int");
        
        RESULT=new String(id);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // lista ::= lista corcheteA id lista_declaracion_var palabrafloat corcheteC 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                 
		if (id.length()>10){
        	id = id.substring(0, 9);
                    
            listaReglas = listaReglas + "WARNING [Regla 16] Declaracion nuevo par final recursiva, ID-FLOAT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
        	listaReglas = listaReglas + "[Regla 16] Declaracion nuevo par final recursiva, ID-FLOAT" + "\n";	
        } 

        /*almaceno id en identificadores y 'float' en tipos*/ 
        identificadores.add(id); tipos.add("float");

        RESULT=new String(id);
        
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        
        }
            
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // lista ::= lista corcheteA id lista_declaracion_var palabrastring corcheteC 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		if (id.length()>10){
        	id = id.substring(0, 9);

            listaReglas = listaReglas + "WARNING [Regla 17] Declaracion nuevo par final recursiva, ID-STRING: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 17] Declaracion nuevo par final recursiva, ID-STRING" + "\n";	
        } 

        /*almaceno id en identificadores y 'string' en tipos*/ 
        identificadores.add(id); tipos.add("string");

        RESULT=new String(id);
                
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
    
        }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // lista ::= corcheteA id lista_declaracion_var palabraint corcheteC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		if (id.length()>10){
        	id = id.substring(0, 9);
                    
            listaReglas = listaReglas + "WARNING [Regla 18] Declaracion nuevo par final, ID-INT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
        	listaReglas = listaReglas + "[Regla 18] Declaracion nuevo par final, ID-INT" + "\n";	
        }  

        /*almaceno id en identificadores y 'int' en tipos*/
        identificadores.add(id); tipos.add("int");
        
        RESULT=new String(id);
        
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        }
            
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // lista ::= corcheteA id lista_declaracion_var palabrafloat corcheteC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		if (id.length()>10){
        	id = id.substring(0, 9);

            listaReglas = listaReglas + "WARNING [Regla 19] Declaracion nuevo par final, ID-FLOAT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 19] Declaracion nuevo par final, ID-FLOAT" + "\n";	
        }

	    /*almaceno id en identificadores y 'float' en tipos*/
	    identificadores.add(id); tipos.add("float");
	    
        RESULT=new String(id);
         
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        
        }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // lista ::= corcheteA id lista_declaracion_var palabrastring corcheteC 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		if (id.length()>10){
        	id = id.substring(0, 9);

            listaReglas = listaReglas + "WARNING [Regla 20] Declaracion nuevo par final, ID-STRING: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 20] Declaracion nuevo par final, ID-STRING" + "\n";	
        } 

        /*almaceno id en identificadores y 'string' en tipos*/
        identificadores.add(id); tipos.add("string");
        
        RESULT=new String(id);
        
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        
        }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // lista_declaracion_var ::= corcheteC asigna corcheteA 
            {
              Object RESULT =null;
		
              listaReglas = listaReglas + "[Regla 21] Fin de una Lista de Declaracion" + "\n"; 
        
        /* Invertimos el array de identificadores para matchear correctamente id-tipo */                 
        Collections.reverse(identificadores);
        
        System.out.println("//---ID y TIPO guardados: case 22---//");
        for(int i=0;i<identificadores.size();i++) {
            System.out.println("id: " + identificadores.get(i) + " tipo: " +tipos.get(i)); 
            
            /* Agrego id - tipo a la tabla de simbolos */                      
            tablaSimbolos.agregarObjeto(identificadores.get(i), tipos.get(i),true);
            
            //**
            allIdentificadores.add(identificadores.get(i));
            allTipos.add(tipos.get(i));
        }                               
            
        //System.out.println("//--------------------------//");

        /* limpiamos los array list para la siguiente declaracion de [id,id,..] := [tipo,tipo,..]*/                                    
        identificadores.clear(); tipos.clear();        
	 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // lista_declaracion_var ::= coma id lista_declaracion_var palabraint coma 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
        if (id.length()>10){
        	id = id.substring(0, 9);

            listaReglas = listaReglas + "WARNING [Regla 22] Declaracion nuevo par, ID-INT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 22] Declaracion nuevo par, ID-INT" + "\n";
        }
            
	    /*almaceno id en identificadores y 'int' en tipos*/
	     identificadores.add(id); tipos.add("int");
	     
	     RESULT=new String(id);
	     
	     CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
         
         }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // lista_declaracion_var ::= coma id lista_declaracion_var palabrafloat coma 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
        if (id.length()>10){
        	id = id.substring(0, 9);
                
            listaReglas = listaReglas + "WARNING [Regla 23] Declaracion nuevo par, ID-FLOAT: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 23] Declaracion nuevo par, ID-FLOAT" + "\n";
        }
            
        /*almaceno id en identificadores y 'float' en tipos*/ 
        identificadores.add(id); tipos.add("float");
        
        RESULT=new String(id);
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        }
        
            return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_declaracion_var ::= coma id lista_declaracion_var palabrastring coma 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object ldv = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
        if (id.length()>10){
        	id = id.substring(0, 9);
                
            listaReglas = listaReglas + "WARNING [Regla 24] Declaracion nuevo par, ID-STRING: excede los 10 caracteres. Es recortado." + "\n";
        } else {
            listaReglas = listaReglas + "[Regla 24] Declaracion nuevo par, ID-STRING" + "\n";
        }
            
        /*almaceno id en identificadores y 'string' en tipos*/ 
        identificadores.add(id); tipos.add("string");
        
        RESULT=new String(id);
        
        CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declaracion_var",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
        
        }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_expresiones ::= expresion 
            {
              List<NodoExpresion> RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			b = new ArrayList<NodoExpresion>();
                b.add(e);
                RESULT = b;

                listaReglas = listaReglas + "[Regla 25] Fin Lista-Expresiones" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_expresiones",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_expresiones ::= lista_expresiones coma expresion 
            {
              List<NodoExpresion> RESULT =null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			le.add(e);
			RESULT = le;
                
			listaReglas = listaReglas + "[Regla 26] Lista-Expresiones Recursiva" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_expresiones",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // condicion ::= parentesisA expresion parentesisC mayor parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMayor(e1, e2);
			
			listaReglas = listaReglas + "[Regla 27] Condicion MAYOR" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // condicion ::= parentesisA expresion parentesisC menor parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMenor(e1, e2);
               
			listaReglas = listaReglas + "[Regla 28] Condicion MENOR" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // condicion ::= parentesisA expresion parentesisC igual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoIgual(e1, e2);

			listaReglas = listaReglas + "[Regla 29] Condicion IGUAL" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // condicion ::= parentesisA expresion parentesisC mayorigual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMayorIgual(e1, e2);
			
			listaReglas = listaReglas + "[Regla 30] Condicion MAYOR-IGUAL" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // condicion ::= parentesisA expresion parentesisC menorigual parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoMenorIgual(e1, e2);
			
			listaReglas = listaReglas + "[Regla 31] Condicion MENOR-IGUAL" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // condicion ::= parentesisA expresion parentesisC distinto parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e1 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e2 = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			RESULT = new NodoDistinto(e1, e2);
			
			listaReglas = listaReglas + "[Regla 32] Condicion DISTINTO" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condicion",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // expresion ::= expresion mas termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoSuma(a, b);

			listaReglas = listaReglas + "[Regla 33] Expresion MAS Termino" + "\n";
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // expresion ::= expresion menos termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = new NodoResta(a, b);
			
			listaReglas = listaReglas + "[Regla 34] Expresion MENOS Termino" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // expresion ::= termino 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;
			
			listaReglas = listaReglas + "[Regla 35] Termino" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // termino ::= termino por factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoMultiplicacion(a, b);
			
			listaReglas = listaReglas + "[Regla 36] Termino PRODUCTO Factor" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // termino ::= termino dividido factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion b = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = new NodoDivision(a, b);

			listaReglas = listaReglas + "[Regla 37] Termino DIVISION Factor" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // termino ::= factor 
            {
              NodoExpresion RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoExpresion a = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT = a;
			
			listaReglas = listaReglas + "[Regla 38] Factor" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("termino",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // factor ::= id 
            {
              NodoExpresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			RESULT =new NodoIdentificador(id); 
			
			listaReglas = listaReglas + "[Regla 39] ID" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // factor ::= constString 
            {
              NodoExpresion RESULT =null;
		int constStringleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int constStringright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String constString = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        if (constString.length()>32){
        	constString = constString.substring(0, 31) + "\"";
                
            listaReglas = listaReglas + "WARNING [Regla 40] CTES: excede los 30 caracteres. Es recortado." + "\n";
        	
        } else {
        	
        	listaReglas = listaReglas + "[Regla 40] CTES" + "\n";
        }
        
        RESULT =new NodoConstanteString(constString);
        
        /*almaceno constString en constantes y 'CTE_STR' en token*/ 
        constantes.add(constString); tokens.add("CTE_STR");
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // factor ::= cteReal 
          {
              	NodoExpresion RESULT =null;
				int cterealleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
				int cterealright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
				String ctereal = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
				 
		        float f= Float.parseFloat(ctereal); 
		        if (Float.isInfinite(f)){ 
		        	
		        	listaReglas = listaReglas + "ERROR [Regla 41] CTER: Mayor a 32bits.";
		        	
		        	throw new RuntimeException("ERROR [Regla 41] CTER: Mayor a 32bits.");
		            
		        } else {
				    RESULT =new NodoConstanteReal(ctereal);
				    
				    listaReglas = listaReglas + "[Regla 41] CTER" + "\n";
		                    
                    /*almaceno consFloat en constantes y 'CTE_F' en token*/ 
                    constantes.add(ctereal); tokens.add("CTE_F");
		        }
		            
		        CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // factor ::= cte 
            {
              NodoExpresion RESULT =null;
		int cteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cteright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String cte = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                try { 
                    Short var_short = Short.valueOf(cte); 
				    RESULT =new NodoConstante(cte);
	
				    listaReglas = listaReglas + "[Regla 42] CTE" + "\n"; 
	
	                /*almaceno consEntera en constantes y 'CTE_E' en token*/ 
	                constantes.add(cte); tokens.add("CTE_E");
                
                }catch(NumberFormatException e) {
                	
                	listaReglas = listaReglas + "ERROR [Regla 42] CTE: Mayor a 16bits.";
		        	
		            throw new RuntimeException("ERROR [Regla 42] CTE: Mayor a 16bits.");
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // factor ::= parentesisA expresion parentesisC 
            {
              NodoExpresion RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
		RESULT = e;
		listaReglas = listaReglas + "[Regla 43] (Expresion)" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // factor ::= filter 
            {
              NodoExpresion RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		NodoFilter f = (NodoFilter)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			RESULT = f;
         
			listaReglas = listaReglas + "[Regla 44] FILTER" + "\n";
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // filter ::= palabrafilter parentesisA guion_bajo mayor expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
            NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Mayor");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMayor(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,">");
              
			listaReglas = listaReglas + "[Regla 45] FILTER MAYOR" + "\n"; 
         
            CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
        return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 47: // filter ::= palabrafilter parentesisA guion_bajo menor expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
            NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";

		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Menor");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMenor(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"<");
             
			listaReglas = listaReglas + "[Regla 46] FILTER MENOR" + "\n"; 
          
            CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
        return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 48: // filter ::= palabrafilter parentesisA guion_bajo mayorigual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
            NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"MayorIgual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMayorIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,">=");
            
			listaReglas = listaReglas + "[Regla 47] FILTER MAYOR-IGUAL" + "\n"; 
          
            CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
        return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 49: // filter ::= palabrafilter parentesisA guion_bajo menorigual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
            NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"MenorIgual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoMenorIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"<=");
              
			listaReglas = listaReglas + "[Regla 48] FILTER MENOR-IGUAL" + "\n"; 
          
            CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
        return CUP$parser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 50: // filter ::= palabrafilter parentesisA guion_bajo distinto expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
            NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Distinto");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoDistinto(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"!=");
          
			listaReglas = listaReglas + "[Regla 49] FILTER DISTINTO" + "\n"; 
          
            CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
          }
        return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // filter ::= palabrafilter parentesisA guion_bajo igual expresion coma corcheteA lista_expresiones corcheteC parentesisC 
          {
              NodoFilter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		NodoExpresion e = (NodoExpresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<NodoExpresion> le = (List<NodoExpresion>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

		List<NodoExpresion> aux_le;
		aux_le = new ArrayList<NodoExpresion>(le);
		
		identificadoraux = "@aux";
		tipoaux = "float";
		identificador = "@c";
		tipo = "float";
		
		NodoExpresion ne1 = le.get(0);
		NodoExpresionBinaria neb = (NodoExpresionBinaria) ne1;
		NodoExpresion ne2 = neb.copy();
		le.remove(0);
		NodoIdentificador aux1 = new NodoIdentificador("@aux");
		NodoIdentificador aux2 = new NodoIdentificador("@aux");
		NodoIdentificador c = new NodoIdentificador("@c");
		NodoSentencia ns = new NodoAsignacion(c, ne1);  
		List<NodoSentencia> lns = new ArrayList<NodoSentencia>();
		lns.add(ns);
		
		List<NodoSentencia> ls = new ArrayList<NodoSentencia>();
		ls = Filter.sentencias(le,"Igual");
		
			RESULT = new NodoFilter(new NodoAsignacion(aux1, e), new NodoIf(new NodoIgual(ne2,aux2),new NodoThen(lns),new NodoElse(ls)),aux_le,"==");
            
			listaReglas = listaReglas + "[Regla 50] FILTER IGUAL" + "\n"; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("filter",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
        	  
        	listaReglas = listaReglas + "Numero de accion invalido ("+CUP$parser$act_num+") encontrado en la tabla de parsing interna.";
        	
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
